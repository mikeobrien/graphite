---
layout: documentation
---

## Routing

### Route Conventions

Routes are generated by convention during initialization. The `DefaultActionSource` enumerates action methods with the configured action method sources, then runs the configured route conventions on those actions to build the routes. 

#### Default Route Convention

Graphite automatically registers the `DefaultRouteConvention`. This convention looks at the action and the configuration to generate the route.

##### Http Method

The HTTP method is determined by the action method name. By default, the action name must begin with one of the supported HTTP methods, initial capped (e.g. `GetUser`, `PostUser`, etc.) And by default, the supported HTTP methods are: `Get`, `Post`, `Put`, `Patch`, `Delete`, `Options`, `Head`, `Trace`, `Connect`. You can configure the supported HTTP methods as follows:

```csharp
.InitializeGraphite(g => g    .ConfigureHttpMethods(m => m
        .Add("AUTH", true, true)
        .Remove(HttpMethod.Trace, HttpMethod.Connect)));
```

When adding an HTTP method, you'll need to also specify whether a request or response body is supported by that method. 

You can override this and specify a custom regex naming convention as follows:

```csharp
.InitializeGraphite(g => g    .WithActionNameConvention(c => "^(?<method>Get|Post|Put|Delete)(?<segments>.*)"));
```

The regex must contain a capture group for the http method and segments, named `method` and `segments` respectively. This regex is also used to find action methods.

You can also pull the supported HTTP methods into your regex as follows:

```csharp
.InitializeGraphite(g => g                
    .WithActionNameConvention(c => $@"^(?<method>{c.SupportedHttpMethods        .Select(m => m.Method.InitialCap()).Join("|")})(?<segments>.*)"));
```

##### Request Parameter

Request parameters are only supported for HTTP methods that allow a request body (For example `GET` doesn't allow a request body). The default route convention checks the HTTP method of the action and if it allows a request body, it looks for a request parameter. The first parameter that meets one the following criteria is considered the request parameter:

1. Parameter is a simple type or has a simple type element *AND* the `FromBodyAttribute` is applied to the parameter (e.g. `SomeAction([FromBodyAttribute] string someParam, ...)` or `SomeAction([FromBodyAttribute] List<string> someParam, ...)`).
2. Parameter is a complex type or has a complex type element *AND* the `FromUriAttribute` is *NOT* applied to the parameter. (e.g. `SomeAction(User someUser, ...)` or `SomeAction(List<User> someUser, ...)`).

The request parameter does *not* have to be the first parameter, just the first that meets one of those criteria. If no parameter meets these criteria, then it is assumed that the action does not expect a request body.

NOTE: Simple types are any of the following nullable or non-nullable types: `enum`, `string`, `decimal`, `DateTime`, `TimeSpan`, `Guid`, `Uri`, `bool`, `byte`, `sbyte`, `ushort`, `short`, `int`, `uint`, `long`, `ulong`, `char`, `double` and `float`.

##### Action Parameters

Action parameters are all parameters that are *NOT* the request parameter. Action parameters can also be the writable properties of a complex type parameter. 

```csharp
public class SomeMoreParams
{
    public string Param3 { get; set; }
    public int Param4 { get; set; }
    public SomeComplexType Param5 { get; set; }
    public int NotAnActionParam { get; private set; } // Private setter
}

public void PostSomething(SomeRequest someRequest, 
    string param1, int param2, SomeMoreParams moreParams)
```

In the example above, `someRequest` is considered to be a request parameter as this is a `POST` which allows a request body and it's the first parameter that is a complex type (and does not have the `FromUriAttribute` applied which explicitly states that it is an action parameter, not a request parameter). All the other parameters are therefore considered action parameters that can be bound. Since `moreParams` is a complex type, its properties are also considered action parameters. So we have the following action parameters:

1. `param1`
2. `param2`
3. `moreParams`
4. `Param3` (via `moreParams`)
5. `Param4` (via `moreParams`)
6. `Param5` (via `moreParams`)

The `NotAnActionParam` property on `SomeMoreParams` is ignored as it is not writable.

These parameters can potentially be bound to request url parameters, querystring parameters, headers, cookies, etc. Action parameters are named as the parameter or property name itself by default, but the name can be overridden with the `NameAttribute` or `FromUriAttribute`.

```csharp
public class SomeMoreParams
{
	[Name("someNewName3")]
    public string Param3 { get; set; }
}

public void SomeAction([Name("someNewName1")] string parameter1Name, 
    [FromUri(Name: "someNewName2")] User parameter2Name,
    SomeMoreParams moreParams)
```

##### Method Segments

By default, action method names make up part of the route url and determine url parameters. The default route convention parses the action method name with the default action name convention regex:

```regex
^(?<method>Get|Post|Put|Delete|...)(?<segments>.*)
```

Everything after the HTTP method in the action method name is considered segments. You can override this regex as explained in the HTTP Methods section above. Once the segments are parsed out, they are split with an underscore. So for example `GetUsers_Id_Permissions` would be parsed into the segments `Users`, `Id`, `Permissions`.

You can override this and specify a custom segment parsing convention as follows:

```csharp
.InitializeGraphite(g => g    .WithActionSegmentsConvention((c, am) => am.Name.Split("_")));
```

##### Url Parameters

Once the segments are parsed, they are matched against the action parameters to determine if any of the segments are url parameters. Lets take the example above:

```csharp
public Response GetUsers_Id_Permissions(Guid id)
```

As mentioned earlier, this would be parsed into the segments `Users`, `Id`, `Permissions`. This action has one parameter: `id`. Since the `Id` segment matches the name of the `id` parameter (case is ignored), the `Id` segment is considered to be a url parameter, whereas the other segments are simply just url segments. The route template would be as follows: `users/{id}/permissions`. 

##### Wildcard Url Parameters

Typically url parameters will bind to a value passed in a url segment. In the example above, a valid url would be `users/9681241f-48e5-469c-bf67-94d5049cb227/permissions` where the guid is passed to the `id` parameter. Graphite also supports wildcard url parameters in two forms. First, passing the raw url from the wildcard on. The following action has a wildcard parameter, which has the `WildcardAttribute` applied. Only one parameter can have this applied.

```csharp
public void GetSomeSegment_SomeParam_SomeWildcard(
    string someParam, [Wildcard] string someWildcard)
```

The default route convention would generate the following route template for the action above: `SomeSegment/{someParam}/{*someWildcard}`. This would end up passing the remainder of the url to `someWildcard`.

The second type of wildcard is variable number of segments. Let's say for example you wanted to pass in a variable number of levels in a hierarchy, e.g. `category/34/76/234/765` and have these map to an array. The following action would enable this:

```csharp
public void GetCategory_Levels(params int[] levels)
```

An array of levels would be passed to `levels` (e.g. `34`, `76`, `234`, `765`).

##### Url Parameter Route Constraints

Route constraints can be applied to url parameters with constraint attributes or conventionally by type. For example, constraining a parameter to alpha characters only:

```csharp
public void Get([Alpha] string param)
```

The following are the available constraints:

| Attribute | Type | Description |
| --- | --- | ----------- |
| `AlphaAttribute` | `string` | Matches uppercase or lowercase Latin alphabet characters (a-z, A-Z) |
| `LengthAttribute` | `string` | Matches a string with the specified length or within a specified range of lengths. |
| `RangeAttribute` | `int`, `long` | Matches an integer within a range of values. |
| `RegexAttribute` | N/A | Matches a regular expression. |
| `MatchTypeAttribute` | `bool`, `DateTime`, `decimal`, `double`, `float`, `Guid`, `int`, `long` | Matches the data type. |

If you want data type constraints for all url parameters, but don't want to explicitly apply them with attributes, Graphite can automatically apply them when configured as follows:

```csharp
.InitializeGraphite(g => g                
    .AutomaticallyConstrainUrlParameterByType());
```

You can also roll your own constraint conventions by implementing `IInlineConstraintBuilder`. This interface has one method, `Build` which returns the Web API route constraint strings for that parameter:

```csharp
public class MyCustomeConstraintBuilder IInlineConstraintBuilder{    public List<string> Build(UrlParameter parameter)
    {
        if (parameter.HasAttribute<SomeAttribute>())
            return new List<string> { "alpha" };
        else
            return new List<string> { };
    }}
```

The complete list of Web API route constraint strings can be found [here](https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2#route-constraints). You can then set your custom constraint builder in the Graphite configuration:

```csharp
.InitializeGraphite(g => g                
    .WithInlineConstraintBuilder<MyCustomeConstraintBuilder>());
```

##### Url Conventions

The route templates are built by url conventions that implement `IUrlConvention`. The `DefaultUrlConvention` is added automatically. This convention takes the handler namespace and action method name segments and combines them to generate the entire route template. 

In order to turn the handler namespace into a route template, the default url convention uses the configured `NamespaceMapping`'s. These take a namespace, and return a route template. The default namespace mapping removes the first namespace level, and then replaces the `.`'s with forward slashes (e.g. `MyApp.Users.Permissions` would be mapped to `Users/Permissions`). You can map the namespace at a certain point in the Graphite configuration as follows:

```csharp
.InitializeGraphite(g => g    .ConfigureNamespaceUrlMapping(u => u        .MapNamespaceAfter<SomeClass>()));
```

In the example above, lets say the full name of `SomeClass` is `MyCompany.MyApp.SomeClass` and the full name of a handler is `MyCompany.MyApp.Users.GetHandler`. Mapping the namespace after `SomeClass` would ignore `MyCompany.MyApp` and only look at the namespace after this. So the url for `GetHandler` would simply be `users`.

You can create your own namespace mappings as follows:


```csharp
.InitializeGraphite(g => g    .ConfigureNamespaceUrlMapping(u => u
        .Clear()        .Add("^MyCo\.(?<namespace>.*?)\.Handlers", "${namespace}")));
```

The example above pulls the namespace in the middle of `MyCo.{...}.Handlers`. The namespace mapping is simply a `Regex.Replace` so you can named capture groups or any other `Regex` features. Multiple namespace mappings can be added, and are matched against the handler namespace. This allows you to create different mappings for different namespaces. If multiple mappings match the same handler namespace, this will result in multiple routes. So you may want to clear the default mapping if this is not desired.

Once the namespace portion of the route template is generated, the default url convention will concatenate the action method segments to create the final route template. So for example, with the default route and url conventions, this:

```csharp
namespace MyApp.Api.Users
{
    public UserHandler
    {
        public User Get_Id_Permissions(Guid id) 
        {
            ...
        }
    }
}
```

...would result in the route template `api/users/{id}/permissions`.

##### Explicit Urls

You can completely override the action's url with the `UrlAttriubute` as follows by specifying a route template:

```csharp
[Url("some/url", "another/url")]
public Response Get()
```

Multiple urls are supported and will create separate routes. As this is a route template, you can specify url parameters:

```csharp
[Url("some/url/{id}")]
public Response Get(Guid id)
```

##### Url Alias

If you simply want an alias to an action you can use the `UrlAliasAttribute` as follows by specifying a route template:

```csharp
[UrlAlias("some/alias", "another/alias")]
public Response Get()
```

Multiple aliases are supported and will create separate routes. As this is a route template, you can specify url parameters:

```csharp
[UrlAlias("some/alias/{id}")]
public Response Get(Guid id)
```

##### Url Prefix 

You can also prefix all your urls as follows:

```csharp
.InitializeGraphite(g => g    .WithUrlPrefix("api/v1"));
```

##### Response Parameter

The response parameter is simply determined by the action method return type. The HTTP method must allow a response body in order for the response parameter to be recognized. If the action method returns nothing then no response parameter is configured for the action.


#### Custom Route Convention

You can completely replace the built in route convention by implementing `IRouteConvention` or by inheriting from `DefaultRouteConvention` and overriding methods. The latter is probably the easiest way to build your own route convention. Route conventions can be configured as follows:

```csharp
.InitializeGraphite(g => g    .ConfigureRouteConventions(r => r
        .Clear() // If desired, clear the default route convention        .Append<MyCustomRouteConvention>()));
```

Multiple route conventions are supported which can result in multiple routes for the same action. If you want to replace the default route convention, you will want to `Clear()` it before appending your own.