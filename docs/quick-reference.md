---
layout: documentation
---

## Quick Reference

Below are examples of some commonly used functionality. See the dedicated section for more information.

### Handlers and Actions

By default, all classes that end with `Handler` are considered handlers. 

```csharp
public class UserHandler
{
    // This is an action
    public List<User> GetUsers()
    {
        ...
    }
    
    // This is not an action
    public List<User> EnumerateUsers()
    {
        ...
    }
}
```

All methods in the handler that have a name that starts with an HTTP method are considered actions.

### Urls

Urls are generated by parsing and concatenating the handler namespace and the action method name. For example:

```csharp
namespace MyApp
{
    public class Global : HttpApplication    {        protected void Application_Start(object sender, EventArgs e)        {            ...        }    }

    namespace Api
    {
        public class MyHandler
        {
            public GetUsers_Id_Permissions(Guid id, string sortBy)
            {
                ...
            }
        }
    }
}
```

By default, the handler namespace is split by `.`, so `MyApp`, `Api`. Next the action method name is split by `_`, the HTTP method is ignored and url parameters are matched by name to the action parameters, so `Users`, `{Id}`, `Permissions`. Next all these segments are concatenated together with a `/`: so `MyApp/Api/Users/{Id}/Permissions`. All non matched action parameters can be bound to other parts of the request such as the querystring, so `MyApp/Api/Users/{Id}/Permissions?sortBy=...`

#### Url Starting Point

In the example above, you probably don't want the url to include the `MyApp` segment but would rather have the url start at `Api`. You can do this by configuring the namespace mapping: 

```csharp
.InitializeGraphite(g => g
    .ConfigureNamespaceUrlMapping(u => u
        .MapNamespaceAfter<Global>()));
```

This will only include the namespace *after* the specified type's namespace. In this case, the namespace of `Global` is `MyApp` so the url will start after that point.


#### Explicit Urls

You can completely override the action's url with the `UrlAttribute` as follows by specifying a route template:

```csharp
[Url("some/url", "another/url")]
public Response Get()
```

Multiple urls are supported and will create separate routes. As this is a route template, you can specify url parameters:

```csharp
[Url("some/url/{id}")]
public Response Get(Guid id)
```

#### Url Alias

If you simply want an alias to an action you can use the `UrlAliasAttribute` as follows by specifying a route template:

```csharp
[UrlAlias("some/alias", "another/alias")]
public Response Get()
```

Multiple aliases are supported and will create separate routes. As this is a route template, you can specify url parameters:

```csharp
[UrlAlias("some/alias/{id}")]
public Response Get(Guid id)
```

#### Url Prefix 

You can also prefix all your urls as follows:

```csharp
.InitializeGraphite(g => g    .WithUrlPrefix("api/v1"));
```

### Url Parameters

An action parameter is a url parameter, if its name matches a segment in the action name. For example:

```csharp
public GetUsers_Id_Permissions(Guid id, string sortBy)
{
    ...
}
```

The `id` parameter is considered a url parameter because it's name matches the `Id` segment. The resulting route template would be `Users/{id}/Permissions`. 

### Querystring

An action parameter can be bound to a querystring parameter (or other things like headers and cookies) if it is *not* a url parameter. For example:

```csharp
public GetUsers_Id_Permissions(Guid id, string sortBy)
{
    ...
}
```

The `id` parameter is considered a url parameter because it's name matches the `Id` segment so could not be bound to a querystring value. The `sortBy` parameter on the other hand does not match any url segments, so can be bound to a querystring value.

### Request

TODO

### Response

The response is simply determined by the action method return type. The HTTP method must allow a response body in order for the response parameter to be recognized. If the action method returns nothing then no response parameter is configured for the action.

#### Response Model

The response can be a POCO, for example:

```csharp
public class UserHandler
{
    public class UserModel
    {
        public string Name { get; set; }
        ...
    }

    public UserModel GetUser()
    {
        ...
    }
}
```

In the example above `GetUser` returns a `UserModel`. If the `accept-type` is `application/json`, this model will get serialized as JSON. 

#### Response String

```csharp
public class UserHandler
{    public string GetUsername1()    {        return "fark";    }
    
    [OutputString("text/plain", "somefile.txt", "ascii")]    public string GetUsername2()    {        return "fark";    }    public OutputString GetUsername3()    {        return new OutputString        {            ContentType = "text/plain",            Filename = "somefile.txt",            Data = "fark",            Encoding = Encoding.ASCII        };    }
}
```

`GetUsername1` simply returns a string. Graphite will try to autodetect HTML or plain text and set the `content-type` accordingly. You can explicitly set a mime type and optional filename and encoding with the `OutputStringAttribute` as demonstrated in `GetUsername2`. You can also return an `OutputString` object if you want to change the mime type, file name and encoding dynamically.

#### Response Stream

```csharp
public class FileHandler
{    public Stream GetFile1()    {        return File.OpenRead(...);    }
    
    [OutputString("application/video", "weddingsinger.mp4", 1048576)]    public Stream GetFile2()    {        return File.OpenRead(...);    }    public OutputStream GetFile3()    {        return new OutputString        {            ContentType = "application/video",            Filename = "weddingsinger.mp4",            Data = File.OpenRead(...),            BufferSize = 1048576        };    }
}
```

`GetFile1` simply returns a stream. Graphite will set the `content-type` to `application/octet-stream`. You can explicitly set a mime type, optional filename and buffer size with the `OutputStreamAttribute` as demonstrated in `GetFile2`. You can also return an `OutputStream` object if you want to change the mime type, file name and buffer size dynamically.

#### Response Bytes

```csharp
public class FileHandler
{    public byte[] GetFile1()    {        return File.ReadAllBytes(...);    }
    
    [OutputBytes("application/video", "weddingsinger.mp4")]    public byte[] GetFile2()    {        return File.ReadAllBytes(...);    }    public OutputBytes GetFile3()    {        return new OutputString        {            ContentType = "application/video",            Filename = "weddingsinger.mp4",            Data = File.ReadAllBytes(...)        };    }
}
```

`GetFile1` simply returns a byte array. Graphite will set the `content-type` to `application/octet-stream`. You can explicitly set a mime type an optional filename with the `OutputBytesAttribute` as demonstrated in `GetFile2`. You can also return an `OutputBytes` object if you want to change the mime type and file name dynamically.


